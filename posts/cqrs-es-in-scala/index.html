<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Hyper Lambda - CQRS/ES in Scala: an overview</title>
        <link rel="stylesheet" type="text/css" href="../../css/main.css" />
        <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,300italic,700|Source+Code+Pro" />
        <link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.hyperlambda.com/rss.xml" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../">hyper λ</a>
            </div>
            <div id="navigation">
                <a href="../../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>CQRS/ES in Scala: an overview</h1>

            <div class="info">
    Posted on July 11, 2015
    
        by Sarunas Valaskevicius
    
</div>

<div id="toc"><ul>
<li><a href="#where-are-we-now">Where are we now?</a></li>
<li><a href="#cqrs-with-akka-actors-and-functional-domain-models-012011">CQRS with Akka actors and functional domain models (01/2011)</a></li>
<li><a href="#akka-dddd-template-032015">Akka DDDD template (03/2015)</a></li>
<li><a href="#reactive-ddd-with-akka-032015">Reactive DDD with Akka (03/2015)</a></li>
<li><a href="#final-thoughts">Final thoughts</a></li>
</ul></div>
<h1 id="where-are-we-now">Where are we now?</h1>
<p><a href="../../posts/cqrs-es-in-haskell/">Last time</a> we’ve looked at implementing a CQRS/ES application in Haskell - a purely functional programming language. This gave us some insights of how we can compose the elements together. Today we’re going to look at some existing CQRS/ES examples in Scala.</p>
<h1 id="cqrs-with-akka-actors-and-functional-domain-models-012011">CQRS with Akka actors and functional domain models (01/2011)</h1>
<p>This is one of the first examples of CQRS in scala. And it also is written in a mostly functional style. One particularly interesting thing to note is that the <code>TradeLifecycle</code> is written as a Finite State Machine actor, which I think is a nice way to encode that an aggregate can be in a few different phases throughout its lifetime.</p>
<p>Both the aggregate and the projection are modelled as Akka actors. One of the drawbacks of this example is that it is not using commands - the messages that are sent to the aggregate (<code>TradeLifecycle</code>) are events and there is no domain logic validation.</p>
<p>The event log that is provided by the example is another Akka actor. It is used as a write-only backend to log the events asynchronously. I would argue that such functionality does not guarantee the successful writes, however, we are discussing a rather minimal example so this can be expected.</p>
<p>Links to the source of the example: <a href="http://debasishg.blogspot.co.uk/2011/01/cqrs-with-akka-actors-and-functional.html">blog</a>, and <a href="https://github.com/debasishg/cqrs-akka">github</a>.</p>
<h1 id="akka-dddd-template-032015">Akka DDDD template (03/2015)</h1>
<p>A Distributed Domain Driven Design example which is aiming to provide a fully scalable CQRS/ES solution as a template for new applications. Both commands and projections (queries) are Akka cluster actors, sharded across the available nodes. The HTTP endpoint is a simple Spray instance and it only proxies the messages to an appropriate cluster.</p>
<p>The write model - <code>BidProcessor</code> is modeled as a persistent actor, and also acts as a state machine, switching to different phases based on the processed commands. When a command has been processed, it notifies the read side that it should update the view.</p>
<p>Because each command processor is a persistent actor on a cluster node, we get a pessimistic concurrency model for aggregates - commands are queued before the aggregate rules are applied. Instead of using locks explicitly the implementation mechanism is based on communication channel to the actor thread.</p>
<p>The view side, or in other words the projection, receives the events from the write side via the Akka’s Persistence module’s views. It updates its data representation according to the persisted events. Currently, the write model in the example notifies the projection to update synchronously, however Akka supports asynchronous notifications as well.</p>
<p>The source code of the described example is available on <a href="https://github.com/boldradius/akka-dddd-template#master">github</a>.</p>
<h1 id="reactive-ddd-with-akka-032015">Reactive DDD with Akka (03/2015)</h1>
<p>One immediately notable difference in this example is the modular structure - each bounded context is implemented in its own namespace - sales, shipping, invoicing. They are also split into separate parts: read-front, read-back, write-front, write-back. This is a nice approach to build modular systems, and allows to extend them easily without modifying the existing deployment.</p>
<p>This is the most complete example that I’ve seen so far. It not only includes the commands and projections, but also <a href="http://cqrs.nu/Faq/sagas">sagas</a>. There is an <code>OrderSaga</code> in the sales context, which either completes a reservation or cancels it depending on the billing result. Unsurprisingly, it is implemented as an Akka actor.</p>
<p>The write side of this example is very similar to the previous one - using Akka’s persistence module to store the events and repopulate an actor - command handler - from the past events.</p>
<p>However the read side here is different. Instead of using Akka’s persistence module’s views, which only allow to receive the updates from one aggregate, the example is using a custom Akka’s serialisation support to send all events to an <a href="http://geteventstore.com/">Event Store</a> instance and implements projections as provided by the Event Store.</p>
<p>While initially the structure of the application looks rather complicated, having read it carefully it I think it is clean and would benefit large systems well. Having said that I’d look for more concise ways to represent the domain for each bounded context.</p>
<p>The blog posts can be found at: <a href="http://pkaczor.blogspot.co.uk/2014/04/reactive-ddd-with-akka.html">blog post 1</a>, <a href="http://pkaczor.blogspot.co.uk/2014/04/reactive-ddd-with-akka-lesson-2.html">blog post 2</a> and <a href="http://pkaczor.blogspot.co.uk/2014/06/reactive-ddd-with-akka-projections.html">blog post 3</a>. Also there are github repositories for both the <a href="https://github.com/pawelkaczor/akka-ddd">akka-ddd</a> library and the discussed example <a href="https://github.com/pawelkaczor/ddd-leaven-akka-v2">ddd-leaven-akka-v2</a>.</p>
<h1 id="final-thoughts">Final thoughts</h1>
<p>All examples that I’ve seen in Scala use Akka. This is not surprising, as actor model fits an aggregate’s description well, and Akka provides a good implementation of it. The resulting systems benefit from Akka’s provided routing of messages and the persistence module. It solves most of the infrastructural complexity. I am curious however to see how an Akka based CQRS system performs in a write-intensive domain - or what is the limit where an alternative implementation e.g. with an optimistic concurrency control would be a better choice?</p>
<p>And whilst Akka provides a good mechanism for the write side, it is less appropriate to write projections in. Many projections need to listen for events coming from a few aggregates, which is not provided by the default persistence module views. A custom message bus is needed to implement such functionality. Integration with other event systems that are running projections, such as the Event Store, works well too. Maybe Akka’s streams module provides what is needed?</p>
<p>A few examples have used finite state machines to define the commands an aggregate can accept. This works well, especially in more complex aggregates, as it both provides a clear view of possible transitions in the system and also ensures its correctness. What I’ve missed and believe would add even more value is to declare the business rules for aggregates in a more concise manner - a DSL describing the state transitions could work well.</p>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'hyperlambda';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

        </div>
        <div id="footer">
            I'm using <a href="http://jaspervdj.be/hakyll">Hakyll</a>!
        </div>
        <script>
         (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
             (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                                  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
         })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

         ga('create', 'UA-64681045-1', 'auto');
         ga('send', 'pageview');

        </script>
    </body>
</html>
